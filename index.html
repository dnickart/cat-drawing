<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title data-i18n="appTitle">Paint-–ø–æ–¥—ñ–±–Ω–∏–π –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∑ Krita-—Ñ—É–Ω–∫—Ü—ñ—è–º–∏</title>
  <style>
    body { margin: 0; font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
    #top-toolbar, #bottom-toolbar {
      background: #ececec; border-top: 1px solid #ccc; border-bottom: 1px solid #ccc; padding: 5px; display: flex; align-items: center; flex-shrink: 0;
    }
    #top-toolbar { border-bottom: none; }
    #bottom-toolbar { border-top: none; justify-content: center; flex-wrap: wrap; }
    .tool-btn { width: 32px; height: 32px; margin-right: 5px; background: #fff; border: 1px solid #aaa; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .tool-btn.active { background: #ddd; }
    #color-picker, #fill-color-picker, #alpha-range, #size-range, #linecap-select, #linejoin-select, #gradient-type-select, #langSelect { margin-right: 10px; }
    #undoBtn, #redoBtn, #clearBtn, #saveBtn, #loadBtn, #zoomInBtn, #zoomOutBtn, #gridToggleBtn, #addLayerBtn, #loadTextureBtn, .filter-btn, .blend-mode-select, .opacity-range { margin-right: 5px; padding: 5px 10px; cursor: pointer; border: 1px solid #aaa; background: #fff; }
    #texturePreview { width: 32px; height: 32px; margin-right: 10px; border: 1px solid #aaa; display: none; object-fit: cover; }
    #main { display: flex; flex: 1; overflow: hidden; }
    #layersPanel { width: 200px; background: #f7f7f7; border-right: 1px solid #ccc; overflow-y: auto; flex-shrink: 0; }
    #layersPanel h3 { margin: 5px; font-size: 14px; }
    #layersList { list-style: none; padding: 0; margin: 0; }
    #layersList li { padding: 5px; border-bottom: 1px solid #ddd; cursor: pointer; display: flex; align-items: center; justify-content: space-between; flex-direction: column; }
    #layersList li.active { background: #ddd; }
    .layer-controls { display: flex; align-items: center; margin-top: 4px; }
    .layer-controls select, .layer-controls input { margin-right: 5px; }
    #canvas-container { position: relative; flex: 1; background: #fff; overflow: hidden; cursor: crosshair; }
    canvas.layerCanvas, canvas.overlayCanvas, canvas.gridCanvas { position: absolute; left: 0; top: 0; }
    #filter-controls { display: none; align-items: center; margin-left: 10px; }
    #filter-controls input { margin: 0 5px; }
  </style>
</head>
<body>
  <!-- –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ -->
  <div id="top-toolbar">
    <select id="langSelect" title="Language">
      <option value="uk">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
      <option value="en">English</option>
    </select>
    <div id="brushBtn" class="tool-btn active" data-i18n-title="toolBrush" title="–ö–∏—Å—Ç—å">üñåÔ∏è</div>
    <div id="eraserBtn" class="tool-btn" data-i18n-title="toolEraser" title="–ì—É–º–∫–∞">üßΩ</div>
    <div id="lineBtn" class="tool-btn" data-i18n-title="toolLine" title="–õ—ñ–Ω—ñ—è">üìè</div>
    <div id="rectBtn" class="tool-btn" data-i18n-title="toolRect" title="–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫">‚ñ≠</div>
    <div id="ellipseBtn" class="tool-btn" data-i18n-title="toolEllipse" title="–ï–ª—ñ–ø—Å">‚ö™</div>
    <div id="gradientBtn" class="tool-btn" data-i18n-title="toolGradient" title="–ì—Ä–∞–¥—ñ—î–Ω—Ç">üé®‚≠£</div>
    <div id="bucketBtn" class="tool-btn" data-i18n-title="toolFill" title="–ó–∞–ª–∏–≤–∫–∞">ü™£</div>
    <div id="eyedropperBtn" class="tool-btn" data-i18n-title="toolEyedropper" title="–ü—ñ–ø–µ—Ç–∫–∞">üé®</div>
    <div id="textBtn" class="tool-btn" data-i18n-title="toolText" title="–¢–µ–∫—Å—Ç">üÖ∞Ô∏è</div>
    <div id="selectBtn" class="tool-btn" data-i18n-title="toolSelect" title="–í–∏–¥—ñ–ª–µ–Ω–Ω—è">üî≤</div>
    <div id="transformBtn" class="tool-btn" data-i18n-title="toolTransform" title="–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è">üîÑ</div>
    <input type="color" id="color-picker" title="–ö–æ–ª—ñ—Ä –∫–æ–Ω—Ç—É—Ä—É" data-i18n-title="colorPicker">
    <input type="color" id="fill-color-picker" title="–ö–æ–ª—ñ—Ä –∑–∞–ª–∏–≤–∫–∏" data-i18n-title="fillColorPicker">
    <input type="range" id="alpha-range" min="0" max="1" step="0.01" value="1" title="–ù–µ–ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å" data-i18n-title="opacity">
    <input type="range" id="size-range" min="1" max="100" value="5" title="–†–æ–∑–º—ñ—Ä –∫–∏—Å—Ç—ñ/–≥—É–º–∫–∏" data-i18n-title="size">
    <select id="linecap-select" title="–ö—ñ–Ω–µ—Ü—å –ª—ñ–Ω—ñ—ó" data-i18n-title="lineCap"><option value="round">Round</option><option value="butt">Butt</option><option value="square">Square</option></select>
    <select id="linejoin-select" title="–ó'—î–¥–Ω–∞–Ω–Ω—è –ª—ñ–Ω—ñ—ó" data-i18n-title="lineJoin"><option value="round">Round</option><option value="bevel">Bevel</option><option value="miter">Miter</option></select>
    <select id="gradient-type-select" title="–¢–∏–ø –≥—Ä–∞–¥—ñ—î–Ω—Ç—É" data-i18n-title="gradientType"><option value="linear">Linear</option><option value="radial">Radial</option></select>
    <button id="loadTextureBtn" data-i18n="loadTexture">–¢–µ–∫—Å—Ç—É—Ä–∞</button>
    <input type="file" id="textureInput" accept="image/*" style="display:none;">
    <img id="texturePreview" alt="Preview">
  </div>
  <div id="main">
    <div id="layersPanel">
      <h3 data-i18n="layers">–®–∞—Ä–∏</h3>
      <ul id="layersList"></ul>
      <button id="addLayerBtn" data-i18n="addLayer">+ –î–æ–¥–∞—Ç–∏ —à–∞—Ä</button>
    </div>
    <div id="canvas-container"></div>
  </div>
  <!-- –ù–∏–∂–Ω—è –ø–∞–Ω–µ–ª—å –¥—ñ–π -->
  <div id="bottom-toolbar">
    <button id="undoBtn" data-i18n="undo">Undo</button>
    <button id="redoBtn" data-i18n="redo">Redo</button>
    <button id="clearBtn" data-i18n="clear">–û—á–∏—Å—Ç–∏—Ç–∏</button>
    <button id="saveBtn" data-i18n="save">–ó–±–µ—Ä–µ–≥—Ç–∏</button>
    <button id="loadBtn" data-i18n="load">–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏</button>
    <button id="zoomInBtn" title="Zoom In" data-i18n-title="zoomIn">‚ûï</button>
    <button id="zoomOutBtn" title="Zoom Out" data-i18n-title="zoomOut">‚ûñ</button>
    <button id="gridToggleBtn" title="Toggle Grid" data-i18n-title="toggleGrid">üî≥</button>
    <button class="filter-btn" id="invertBtn" data-i18n="invert">Invert</button>
    <button class="filter-btn" id="grayscaleBtn" data-i18n="grayscale">Grayscale</button>
    <button class="filter-btn" id="brightnessBtn" data-i18n="brightness">Brightness</button>
    <input type="range" id="brightnessRange" min="-100" max="100" value="0" style="display:none;">
    <button class="filter-btn" id="contrastBtn" data-i18n="contrast">Contrast</button>
    <input type="range" id="contrastRange" min="-100" max="100" value="0" style="display:none;">
    <input type="file" id="loadInput" accept="image/*" title="Load Image" data-i18n-title="loadImage" style="display:none;">
  </div>
  <script>
    // –ü–µ—Ä–µ–∫–ª–∞–¥
    const i18n = {
      uk: {
        appTitle: 'Paint-–ø–æ–¥—ñ–±–Ω–∏–π –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∑ Krita-—Ñ—É–Ω–∫—Ü—ñ—è–º–∏',
        toolBrush: '–ö–∏—Å—Ç—å', toolEraser: '–ì—É–º–∫–∞', toolLine: '–õ—ñ–Ω—ñ—è', toolRect: '–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫', toolEllipse: '–ï–ª—ñ–ø—Å', toolGradient: '–ì—Ä–∞–¥—ñ—î–Ω—Ç', toolFill: '–ó–∞–ª–∏–≤–∫–∞', toolEyedropper: '–ü—ñ–ø–µ—Ç–∫–∞', toolText: '–¢–µ–∫—Å—Ç', toolSelect: '–í–∏–¥—ñ–ª–µ–Ω–Ω—è', toolTransform: '–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü—ñ—è',
        colorPicker: '–ö–æ–ª—ñ—Ä –∫–æ–Ω—Ç—É—Ä—É', fillColorPicker: '–ö–æ–ª—ñ—Ä –∑–∞–ª–∏–≤–∫–∏', opacity: '–ù–µ–ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å', size: '–†–æ–∑–º—ñ—Ä', lineCap: '–ö—ñ–Ω–µ—Ü—å –ª—ñ–Ω—ñ—ó', lineJoin: '–ó‚Äô—î–¥–Ω–∞–Ω–Ω—è –ª—ñ–Ω—ñ—ó', gradientType: '–¢–∏–ø –≥—Ä–∞–¥—ñ—î–Ω—Ç—É',
        loadTexture: '–¢–µ–∫—Å—Ç—É—Ä–∞', layers: '–®–∞—Ä–∏', addLayer: '+ –î–æ–¥–∞—Ç–∏ —à–∞—Ä', undo: '–°–∫–∞—Å—É–≤–∞—Ç–∏', redo: '–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏', clear: '–û—á–∏—Å—Ç–∏—Ç–∏', save: '–ó–±–µ—Ä–µ–≥—Ç–∏', load: '–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏', zoomIn: '–ó–±—ñ–ª—å—à–∏—Ç–∏', zoomOut: '–ó–º–µ–Ω—à–∏—Ç–∏', toggleGrid: '–ü–æ–∫–∞–∑–∞—Ç–∏/–ü—Ä–∏—Ö–æ–≤–∞—Ç–∏ —Å—ñ—Ç–∫—É', loadImage: '–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è',
        invert: '–Ü–Ω–≤–µ—Ä—Ç—É–≤–∞—Ç–∏', grayscale: '–°—ñ—Ä–∏–π', brightness: '–Ø—Å–∫—Ä–∞–≤—ñ—Å—Ç—å', contrast: '–ö–æ–Ω—Ç—Ä–∞—Å—Ç'
      },
      en: {
        appTitle: 'Paint-like Editor with Krita Features',
        toolBrush: 'Brush', toolEraser: 'Eraser', toolLine: 'Line', toolRect: 'Rectangle', toolEllipse: 'Ellipse', toolGradient: 'Gradient', toolFill: 'Fill', toolEyedropper: 'Eyedropper', toolText: 'Text', toolSelect: 'Select', toolTransform: 'Transform',
        colorPicker: 'Stroke Color', fillColorPicker: 'Fill Color', opacity: 'Opacity', size: 'Size', lineCap: 'Line Cap', lineJoin: 'Line Join', gradientType: 'Gradient Type',
        loadTexture: 'Texture', layers: 'Layers', addLayer: '+ Add Layer', undo: 'Undo', redo: 'Redo', clear: 'Clear', save: 'Save', load: 'Load', zoomIn: 'Zoom In', zoomOut: 'Zoom Out', toggleGrid: 'Toggle Grid', loadImage: 'Load Image',
        invert: 'Invert', grayscale: 'Grayscale', brightness: 'Brightness', contrast: 'Contrast'
      }
    };
    function updateLanguage(lang) {
      document.documentElement.lang = lang;
      document.querySelector('title').textContent = i18n[lang].appTitle;
      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.getAttribute('data-i18n-title'); if (i18n[lang][key]) el.title = i18n[lang][key];
      });
      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n'); if (i18n[lang][key]) el.textContent = i18n[lang][key];
      });
    }
    const langSelect = document.getElementById('langSelect');
    langSelect.onchange = () => updateLanguage(langSelect.value);
    updateLanguage('uk');

    // –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–¥
    const container = document.getElementById('canvas-container');
    const dpr = window.devicePixelRatio || 1;
    let scale = 1, offsetX = 0, offsetY = 0;
    let tool = 'brush'; let drawing = false; let startX = 0, startY = 0;
    let selection = null; let transformMode = false;
    let textureImage = null, textureData = null, textureWidth = 0, textureHeight = 0;
    const loadTextureBtnEl = document.getElementById('loadTextureBtn');
    const textureInputEl = document.getElementById('textureInput');
    const texturePreview = document.getElementById('texturePreview');
    loadTextureBtnEl.onclick = () => textureInputEl.click();
    textureInputEl.onchange = e => {
      const file = e.target.files[0]; if (!file) return;
      const img = new Image(); const reader = new FileReader(); reader.onload = ev => {
        img.onload = () => {
          textureImage = img;
          const off = document.createElement('canvas'); off.width = img.width; off.height = img.height;
          const offCtx = off.getContext('2d'); offCtx.drawImage(img, 0, 0);
          const imgd = offCtx.getImageData(0, 0, img.width, img.height);
          textureData = imgd.data; textureWidth = img.width; textureHeight = img.height;
          texturePreview.src = ev.target.result; texturePreview.style.display = 'inline-block';
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    };
    const toolsMap = { brushBtn: 'brush', eraserBtn: 'eraser', lineBtn: 'line', rectBtn: 'rect', ellipseBtn: 'ellipse', gradientBtn: 'gradient', bucketBtn: 'bucket', eyedropperBtn: 'eyedropper', textBtn: 'text', selectBtn: 'select', transformBtn: 'transform' };
    Object.keys(toolsMap).forEach(id => { document.getElementById(id).onclick = () => selectTool(id); });
    const colorPicker = document.getElementById('color-picker');
    const fillPicker = document.getElementById('fill-color-picker');
    const alphaRange = document.getElementById('alpha-range');
    const sizeRange = document.getElementById('size-range');
    const linecapSelect = document.getElementById('linecap-select');
    const linejoinSelect = document.getElementById('linejoin-select');
    const gradientTypeSelect = document.getElementById('gradient-type-select');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const saveBtn = document.getElementById('saveBtn');
    const loadBtn = document.getElementById('loadBtn');
    const loadInput = document.getElementById('loadInput');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const gridToggleBtn = document.getElementById('gridToggleBtn');
    const invertBtn = document.getElementById('invertBtn');
    const grayscaleBtn = document.getElementById('grayscaleBtn');
    const brightnessBtn = document.getElementById('brightnessBtn');
    const brightnessRange = document.getElementById('brightnessRange');
    const contrastBtn = document.getElementById('contrastBtn');
    const contrastRange = document.getElementById('contrastRange');
    const undoRedoLimit = 50;
    let layers = [], activeLayerIndex = -1;
    const layersList = document.getElementById('layersList');
    const addLayerBtn = document.getElementById('addLayerBtn'); addLayerBtn.onclick = () => addLayer();
    const overlayCanvas = document.createElement('canvas'); overlayCanvas.className='overlayCanvas'; container.appendChild(overlayCanvas);
    const overlayCtx = overlayCanvas.getContext('2d');
    const gridCanvas = document.createElement('canvas'); gridCanvas.className='gridCanvas'; container.appendChild(gridCanvas);
    const gridCtx = gridCanvas.getContext('2d'); let showGrid = false;
    function resizeAll() {
      const rect = container.getBoundingClientRect(); const w = rect.width * dpr, h = rect.height * dpr;
      [overlayCanvas, gridCanvas].forEach(c => { c.width = w; c.height = h; c.style.width = rect.width + 'px'; c.style.height = rect.height + 'px'; });
      layers.forEach(layer => resizeLayerCanvas(layer)); drawGrid();
    }
    function resizeLayerCanvas(layer) {
      const rect = container.getBoundingClientRect(); const w = rect.width * dpr, h = rect.height * dpr;
      const temp = document.createElement('canvas'); temp.width = layer.canvas.width; temp.height = layer.canvas.height; temp.getContext('2d').drawImage(layer.canvas, 0, 0);
      layer.canvas.width = w; layer.canvas.height = h; layer.canvas.style.width = rect.width + 'px'; layer.canvas.style.height = rect.height + 'px'; layer.ctx.scale(dpr, dpr);
      layer.ctx.drawImage(temp, 0, 0, temp.width/dpr, temp.height/dpr, 0, 0, w/dpr, h/dpr);
    }
    window.addEventListener('resize', resizeAll);
    function addLayer() {
      const layerCanvas = document.createElement('canvas'); layerCanvas.className='layerCanvas'; layerCanvas.style.mixBlendMode='normal'; layerCanvas.style.opacity='1'; container.insertBefore(layerCanvas, overlayCanvas);
      const ctx = layerCanvas.getContext('2d'); const layer={canvas:layerCanvas,ctx,history:[],redo:[]}; layers.push(layer); activeLayerIndex=layers.length-1; selectLayerUI(); resizeLayerCanvas(layer); saveState();
    }
    function selectLayerUI() {
      layersList.innerHTML=''; layers.forEach((layer,idx)=>{
        const li=document.createElement('li'); li.textContent=`–®–∞—Ä ${idx+1}`; if(idx===activeLayerIndex)li.classList.add('active'); li.onclick=()=>{activeLayerIndex=idx;selectLayerUI();};
        const controls=document.createElement('div'); controls.className='layer-controls';
        const vis=document.createElement('input'); vis.type='checkbox'; vis.checked=true; vis.title='–í–∏–¥–∏–º—ñ—Å—Ç—å'; vis.onchange=e=>layer.canvas.style.display=e.target.checked?'block':'none';
        const opacity=document.createElement('input'); opacity.type='range'; opacity.min=0;opacity.max=1;opacity.step=0.01;opacity.value=layer.canvas.style.opacity||1;opacity.className='opacity-range';opacity.title='–ù–µ–ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—å —à–∞—Ä—É';opacity.oninput=()=>layer.canvas.style.opacity=opacity.value;
        const blend=document.createElement('select'); blend.className='blend-mode-select'; blend.title='–†–µ–∂–∏–º –∑–º—ñ—à—É–≤–∞–Ω–Ω—è';['normal','multiply','screen','overlay','darken','lighten','color-dodge','color-burn','hard-light','soft-light'].forEach(mode=>{const opt=document.createElement('option');opt.value=mode;opt.textContent=mode;blend.appendChild(opt);} ); blend.onchange=()=>layer.canvas.style.mixBlendMode=blend.value;
        controls.appendChild(vis);controls.appendChild(opacity);controls.appendChild(blend); li.appendChild(controls); layersList.appendChild(li);
      });
    }
    function selectTool(id) { document.querySelectorAll('.tool-btn').forEach(b=>b.classList.remove('active'));document.getElementById(id).classList.add('active'); tool=toolsMap[id]; selection=null; transformMode=(tool==='transform'); overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height); }
    function saveState() { const layer=layers[activeLayerIndex]; if(!layer)return; const img=layer.ctx.getImageData(0,0,layer.canvas.width,layer.canvas.height); layer.history.push(img); if(layer.history.length>undoRedoLimit)layer.history.shift(); layer.redo=[]; }
    undoBtn.onclick=()=>{const layer=layers[activeLayerIndex]; if(!layer)return; if(layer.history.length>1){const last=layer.history.pop();layer.redo.push(last);const prev=layer.history[layer.history.length-1];layer.ctx.putImageData(prev,0,0);}};
    redoBtn.onclick=()=>{const layer=layers[activeLayerIndex]; if(!layer)return; if(layer.redo.length){const img=layer.redo.pop();layer.history.push(img);layer.ctx.putImageData(img,0,0);}};
    clearBtn.onclick=()=>{if(!layers[activeLayerIndex])return;saveState();layers[activeLayerIndex].ctx.clearRect(0,0,layers[activeLayerIndex].canvas.width,layers[activeLayerIndex].canvas.height);};
    saveBtn.onclick=()=>{const rect=container.getBoundingClientRect();const temp=document.createElement('canvas');temp.width=rect.width*dpr;temp.height=rect.height*dpr;const tctx=temp.getContext('2d');tctx.scale(dpr,dpr);layers.forEach(layer=>tctx.drawImage(layer.canvas,0,0,rect.width,rect.height));const link=document.createElement('a');link.download='drawing.png';link.href=temp.toDataURL('image/png');link.click();};
    loadBtn.onclick=()=>loadInput.click(); loadInput.onchange=e=>{const file=e.target.files[0]; if(!file)return; const img=new Image(); const reader=new FileReader(); reader.onload=ev=>{img.onload=()=>{addLayer();const layer=layers[activeLayerIndex];layer.ctx.drawImage(img,0,0,layer.canvas.width/dpr,layer.canvas.height/dpr);saveState();};img.src=ev.target.result;};reader.readAsDataURL(file);e.target.value='';};
    function applyTransform(){container.style.transform=`translate(${offsetX}px,${offsetY}px) scale(${scale})`;container.style.transformOrigin='0 0';drawGrid();}
    zoomInBtn.onclick=()=>{scale*=1.2;applyTransform();}; zoomOutBtn.onclick=()=>{scale/=1.2;applyTransform();};
    gridToggleBtn.onclick=()=>{showGrid=!showGrid;drawGrid();}; function drawGrid(){const rect=container.getBoundingClientRect();gridCtx.clearRect(0,0,gridCanvas.width,gridCanvas.height);if(!showGrid)return;const step=25*scale;gridCtx.save();gridCtx.scale(dpr,dpr);gridCtx.strokeStyle='#ccc';gridCtx.lineWidth=1;for(let x=0;x<rect.width;x+=step){gridCtx.beginPath();gridCtx.moveTo(x,0);gridCtx.lineTo(x,rect.height);gridCtx.stroke();}for(let y=0;y<rect.height;y+=step){gridCtx.beginPath();gridCtx.moveTo(0,y);gridCtx.lineTo(rect.width,y);gridCtx.stroke();}gridCtx.restore();}
    function getCanvasCoords(e){const rect=container.getBoundingClientRect();let clientX=e.clientX,clientY=e.clientY;if(e.touches&&e.touches[0]){clientX=e.touches[0].clientX;clientY=e.touches[0].clientY;}let x=(clientX-rect.left-offsetX)/scale;let y=(clientY-rect.top-offsetY)/scale;return{x:x*dpr,y:y*dpr};}
    container.addEventListener('mousedown',startDrawing);container.addEventListener('touchstart',startDrawing);container.addEventListener('mousemove',drawingMove);container.addEventListener('touchmove',drawingMove);container.addEventListener('mouseup',endDrawing);container.addEventListener('touchend',endDrawing);
    window.addEventListener('keydown',e=>{if(e.key===' '){e.preventDefault();panMode=true;container.style.cursor='grab';}});
    window.addEventListener('keyup',e=>{if(e.key===' '){panMode=false;container.style.cursor='crosshair';panStart=null;}});
    let panMode=false, panStart=null;
    function startDrawing(e){if(panMode){panStart={x:e.clientX-offsetX,y:e.clientY-offsetY};return;}if(!layers[activeLayerIndex])return;e.preventDefault();drawing=true;const pos=getCanvasCoords(e);startX=pos.x;startY=pos.y;const layer=layers[activeLayerIndex];saveState();if(tool==='bucket')floodFill(pos.x,pos.y);else if(tool==='eyedropper')pickColor(pos.x,pos.y);else if(tool==='text'){insertText(pos.x,pos.y);drawing=false;}else if(tool==='select')startSelection(pos.x,pos.y);else if(tool==='transform')startTransform(pos.x,pos.y);} 
    function drawingMove(e){if(panMode&&panStart){offsetX=e.clientX-panStart.x;offsetY=e.clientY-panStart.y;applyTransform();return;}if(!drawing)return;const pos=getCanvasCoords(e);const layer=layers[activeLayerIndex];layer.ctx.lineWidth=sizeRange.value;layer.ctx.lineCap=linecapSelect.value;layer.ctx.lineJoin=linejoinSelect.value;const rgba=hexToRgba(colorPicker.value,alphaRange.value);const fillRgba=hexToRgba(fillPicker.value,alphaRange.value);if(tool==='brush'||tool==='eraser'){layer.ctx.strokeStyle=(tool==='eraser')?'rgba(255,255,255,1)':`rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`;layer.ctx.beginPath();layer.ctx.moveTo(startX/dpr,startY/dpr);layer.ctx.lineTo(pos.x/dpr,pos.y/dpr);layer.ctx.stroke();startX=pos.x;startY=pos.y;}else if(['line','rect','ellipse','gradient'].includes(tool)){drawOverlayShape(startX,startY,pos.x,pos.y);}else if(tool==='select'&&selection&&selection.moving){const dx=pos.x-selection.moveStart.x;const dy=pos.y-selection.moveStart.y;selection.currentX=selection.origX+dx;selection.currentY=selection.origY+dy;drawSelectionOverlay();}else if(tool==='transform'&&selection&&selection.transforming){updateTransform(pos.x,pos.y);} }
    function endDrawing(e){if(panMode){panStart=null;return;}if(!drawing)return;drawing=false;const pos=getCanvasCoords(e);const layer=layers[activeLayerIndex];layer.ctx.lineWidth=sizeRange.value;layer.ctx.lineCap=linecapSelect.value;layer.ctx.lineJoin=linejoinSelect.value;if(['line','rect','ellipse','gradient'].includes(tool)){drawFinalShape(startX,startY,pos.x,pos.y);overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);}else if(tool==='select'){if(selection&&selection.selecting)finalizeSelection(pos.x,pos.y);else if(selection&&selection.moving)commitSelection();}else if(tool==='transform'){if(selection&&selection.transforming)finalizeTransform();}} 
    function drawOverlayShape(x0,y0,x1,y1){overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);overlayCtx.save();overlayCtx.scale(dpr,dpr);const rgba=hexToRgba(colorPicker.value,alphaRange.value);overlayCtx.strokeStyle=`rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`;if(tool==='gradient'){const type=gradientTypeSelect.value;let grad;if(type==='linear')grad=overlayCtx.createLinearGradient(x0/dpr,y0/dpr,x1/dpr,y1/dpr);else grad=overlayCtx.createRadialGradient((x0+x1)/(2*dpr),(y0+y1)/(2*dpr),0,(x0+x1)/(2*dpr),(y0+y1)/(2*dpr),Math.hypot((x1-x0)/(2*dpr),(y1-y0)/(2*dpr)));grad.addColorStop(0,fillPicker.value);grad.addColorStop(1,colorPicker.value);overlayCtx.fillStyle=grad;}else if(textureImage){const pattern=overlayCtx.createPattern(textureImage,'repeat');overlayCtx.fillStyle=pattern;}else{const fillRgba=hexToRgba(fillPicker.value,alphaRange.value);overlayCtx.fillStyle=`rgba(${fillRgba.r},${fillRgba.g},${fillRgba.b},${fillRgba.a})`;}overlayCtx.lineWidth=sizeRange.value;overlayCtx.lineCap=linecapSelect.value;overlayCtx.lineJoin=linejoinSelect.value;const xs=x0/dpr,ys=y0/dpr,xe=x1/dpr,ye=y1/dpr;overlayCtx.beginPath();if(tool==='line'){overlayCtx.moveTo(xs,ys);overlayCtx.lineTo(xe,ye);overlayCtx.stroke();}else if(tool==='rect'||tool==='gradient'){overlayCtx.rect(xs,ys,xe-xs,ye-ys);overlayCtx.fill();overlayCtx.stroke();}else if(tool==='ellipse'){overlayCtx.ellipse((xs+xe)/2,(ys+ye)/2,Math.abs(xe-xs)/2,Math.abs(ye-ys)/2,0,0,2*Math.PI);overlayCtx.fill();overlayCtx.stroke();}overlayCtx.restore();}
    function drawFinalShape(x0,y0,x1,y1){const layer=layers[activeLayerIndex];layer.ctx.save();layer.ctx.scale(1,1);const rgba=hexToRgba(colorPicker.value,alphaRange.value);layer.ctx.strokeStyle=(tool==='eraser')?'rgba(255,255,255,1)':`rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`;if(tool==='gradient'){const type=gradientTypeSelect.value;let grad;if(type==='linear')grad=layer.ctx.createLinearGradient(x0/dpr,y0/dpr,x1/dpr,y1/dpr);else grad=layer.ctx.createRadialGradient((x0+x1)/(2*dpr),(y0+y1)/(2*dpr),0,(x0+x1)/(2*dpr),(y0+y1)/(2*dpr),Math.hypot((x1-x0)/(2*dpr),(y1-y0)/(2*dpr)));grad.addColorStop(0,fillPicker.value);grad.addColorStop(1,colorPicker.value);layer.ctx.fillStyle=grad;}else if(textureImage){const pattern=layer.ctx.createPattern(textureImage,'repeat');layer.ctx.fillStyle=pattern;}else{const fillRgba=hexToRgba(fillPicker.value,alphaRange.value);layer.ctx.fillStyle=`rgba(${fillRgba.r},${fillRgba.g},${fillRgba.b},${fillRgba.a})`;}layer.ctx.lineWidth=sizeRange.value;layer.ctx.lineCap=linecapSelect.value;layer.ctx.lineJoin=linejoinSelect.value;const xs=x0/dpr,ys=y0/dpr,xe=x1/dpr,ye=y1/dpr;layer.ctx.beginPath();if(tool==='line'){layer.ctx.moveTo(xs,ys);layer.ctx.lineTo(xe,ye);layer.ctx.stroke();}else if(tool==='rect'||tool==='gradient'){layer.ctx.rect(xs,ys,xe-xs,ye-ys);layer.ctx.fill();layer.ctx.stroke();}else if(tool==='ellipse'){layer.ctx.ellipse((xs+xe)/2,(ys+ye)/2,Math.abs(xe-xs)/2,Math.abs(ye-ys)/2,0,0,2*Math.PI);layer.ctx.fill();layer.ctx.stroke();}layer.ctx.restore();}
    function floodFill(x,y){const layer=layers[activeLayerIndex];const img=layer.ctx.getImageData(0,0,layer.canvas.width,layer.canvas.height);const width=img.width,height=img.height;const targetIdx=(Math.floor(y)*width+Math.floor(x))*4;const targetColor=img.data.slice(targetIdx,targetIdx+4);let useTexture=textureImage!==null;let fillRGBA=null;if(!useTexture){const fill=hexToRgba(fillPicker.value,alphaRange.value);fillRGBA=[fill.r,fill.g,fill.b,Math.round(fill.a*255)];if(colorsMatch(targetColor,fillRGBA))return;}const stack=[];stack.push({y:Math.floor(y),x:Math.floor(x)});while(stack.length){const {x:sx,y:sy}=stack.pop();let nx=sx;let idx=(sy*width+nx)*4;while(nx>=0&&colorsMatch(img.data.slice(idx,idx+4),targetColor)){nx--;idx-=4;}nx++;let spanUp=false,spanDown=false;while(nx<width&&colorsMatch(img.data.slice((sy*width+nx)*4,(sy*width+nx)*4+4),targetColor)){const i=(sy*width+nx)*4;if(!useTexture){img.data[i]=fillRGBA[0];img.data[i+1]=fillRGBA[1];img.data[i+2]=fillRGBA[2];img.data[i+3]=fillRGBA[3];}else{const px=nx%textureWidth,py=sy%textureHeight;const ti=(py*textureWidth+px)*4;img.data[i]=textureData[ti];img.data[i+1]=textureData[ti+1];img.data[i+2]=textureData[ti+2];img.data[i+3]=textureData[ti+3];}if(sy>0){const idxUp=((sy-1)*width+nx)*4;if(colorsMatch(img.data.slice(idxUp,idxUp+4),targetColor)){if(!spanUp){stack.push({x:nx,y:sy-1});spanUp=true;}}else spanUp=false;}if(sy<height-1){const idxDown=((sy+1)*width+nx)*4;if(colorsMatch(img.data.slice(idxDown,idxDown+4),targetColor)){if(!spanDown){stack.push({x:nx,y:sy+1});spanDown=true;}}else spanDown=false;}nx++;}}layer.ctx.putImageData(img,0,0);}function colorsMatch(a,b){return a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3];}
    function pickColor(x,y){const layer=layers[activeLayerIndex];const img=layer.ctx.getImageData(Math.floor(x),Math.floor(y),1,1).data;const hex='#'+((1<<24)+(img[0]<<16)+(img[1]<<8)+img[2]).toString(16).slice(1);colorPicker.value=hex;}
    function insertText(x,y){const text=prompt(i18n[langSelect.value].toolText);if(!text)return;const layer=layers[activeLayerIndex];layer.ctx.save();layer.ctx.scale(1,1);const c=hexToRgba(colorPicker.value,alphaRange.value);layer.ctx.fillStyle=`rgba(${c.r},${c.g},${c.b},${c.a})`;layer.ctx.font=`${sizeRange.value*2}px sans-serif`;layer.ctx.fillText(text,x/dpr,y/dpr);layer.ctx.restore();}
    function startSelection(x,y){selection={selecting:true,x0:x,y0:y,x1:x,y1:y,moving:false};}
    function finalizeSelection(x,y){selection.selecting=false;const x0=Math.min(selection.x0,x),y0=Math.min(selection.y0,y);const x1=Math.max(selection.x0,x),y1=Math.max(selection.y0,y);const w=x1-x0,h=y1-y0;if(w<1||h<1){selection=null;overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);return;}const layer=layers[activeLayerIndex];const data=layer.ctx.getImageData(x0,y0,w,h);layer.ctx.clearRect(x0,y0,w,h);selection={data,width:w,height:h,origX:x0,origY:y0,currentX:x0,currentY:y0,moving:true,moveStart:{x:x,y:y},transforming:false};drawSelectionOverlay();}
    function drawSelectionOverlay(){overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);overlayCtx.save();overlayCtx.scale(1,1);overlayCtx.putImageData(selection.data,selection.currentX,selection.currentY);overlayCtx.strokeStyle='blue';overlayCtx.lineWidth=1;overlayCtx.strokeRect(selection.currentX,selection.currentY,selection.width,selection.height);overlayCtx.restore();}
    function commitSelection(){const layer=layers[activeLayerIndex];layer.ctx.putImageData(selection.data,selection.currentX,selection.currentY);overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);selection=null;}
    function startTransform(x,y){if(!selection)return;selection.transforming=true;selection.transformStart={x,y};selection.origData=selection.data;}
    function updateTransform(x,y){if(!selection||!selection.transforming)return;}
    function finalizeTransform(){if(!selection)return;selection.transforming=false;overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);}
    function hexToRgba(hex,alpha){const c=hex.replace('#','');const num=parseInt(c,16);return{r:num>>16,g:(num>>8)&255,b:num&255,a:parseFloat(alpha)};}
    invertBtn.onclick=()=>applyFilter('invert');grayscaleBtn.onclick=()=>applyFilter('grayscale');brightnessBtn.onclick=()=>{brightnessRange.style.display=brightnessRange.style.display==='inline'?'none':'inline';};brightnessRange.oninput=()=>applyFilter('brightness',parseInt(brightnessRange.value));contrastBtn.onclick=()=>{contrastRange.style.display=contrastRange.style.display==='inline'?'none':'inline';};contrastRange.oninput=()=>applyFilter('contrast',parseInt(contrastRange.value));
    function applyFilter(type,value=0){const layer=layers[activeLayerIndex];if(!layer)return;saveState();const imgData=layer.ctx.getImageData(0,0,layer.canvas.width,layer.canvas.height);const data=imgData.data;if(type==='invert'){for(let i=0;i<data.length;i+=4){data[i]=255-data[i];data[i+1]=255-data[i+1];data[i+2]=255-data[i+2];}}else if(type==='grayscale'){for(let i=0;i<data.length;i+=4){const avg=0.299*data[i]+0.587*data[i+1]+0.114*data[i+2];data[i]=data[i+1]=data[i+2]=avg;}}else if(type==='brightness'){const b=value;for(let i=0;i<data.length;i+=4){data[i]=clamp(data[i]+b,0,255);data[i+1]=clamp(data[i+1]+b,0,255);data[i+2]=clamp(data[i+2]+b,0,255);}}else if(type==='contrast'){const c=value;const factor=(259*(c+255))/(255*(259-c));for(let i=0;i<data.length;i+=4){data[i]=clamp(factor*(data[i]-128)+128,0,255);data[i+1]=clamp(factor*(data[i+1]-128)+128,0,255);data[i+2]=clamp(factor*(data[i+2]-128)+128,0,255);}}layer.ctx.putImageData(imgData,0,0);}function clamp(v,min,max){return v<min?min:v>max?max:v;}
    window.addEventListener('load',()=>{addLayer();resizeAll();applyTransform();});
  </script>
</body>
</html>
